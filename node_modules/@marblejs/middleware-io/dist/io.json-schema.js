"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IoTag;
(function (IoTag) {
    IoTag["BOOLEAN"] = "BooleanType";
    IoTag["NUMBER"] = "NumberType";
    IoTag["STRING"] = "StringType";
    IoTag["UNDEFINED"] = "UndefinedType";
    IoTag["NULL"] = "NullType";
    IoTag["LITERAL"] = "LiteralType";
    IoTag["UNION"] = "UnionType";
    IoTag["KEYOF"] = "KeyofType";
    IoTag["INTERSECTION"] = "IntersectionType";
    IoTag["ARRAY"] = "ArrayType";
    IoTag["TUPLE"] = "TupleType";
    IoTag["INTERFACE"] = "InterfaceType";
    IoTag["PARTIAL"] = "PartialType";
    IoTag["EXACT"] = "ExactType";
    IoTag["DICTIONARY"] = "DictionaryType";
    IoTag["REFINEMENT"] = "RefinementType";
    IoTag["CUSTOM_JSON_SCHEMA"] = "CustomJsonSchemaType";
})(IoTag || (IoTag = {}));
const undefinedJsonType = Object.freeze({ type: 'undefined' });
/**
 * Returns true if element is union which had undefined elements
 */
const removeUndefinedValuesFromUnion = (jsonSchema) => {
    if (jsonSchema.anyOf) {
        const elements = jsonSchema.anyOf;
        jsonSchema.anyOf = elements.filter(e => e !== undefinedJsonType);
        return elements.length != jsonSchema.anyOf.length;
    }
    return false;
};
const IoTypes = {
    [IoTag.BOOLEAN]: () => ({ type: 'boolean' }),
    [IoTag.NUMBER]: (_, supertypes) => supertypes.some(type => type.name === 'Int')
        ? { type: 'integer' }
        : { type: 'number' },
    [IoTag.STRING]: () => ({ type: 'string' }),
    [IoTag.UNDEFINED]: () => undefinedJsonType,
    [IoTag.NULL]: () => ({ type: 'null' }),
    [IoTag.LITERAL]: (type) => ({ enum: [type.value] }),
    [IoTag.UNION]: (type) => type.types.every(element => exports.getTag(element) === IoTag.LITERAL)
        ? { enum: type.types.map((element) => element.value) }
        : { anyOf: type.types.map(type => convert(type)) },
    [IoTag.KEYOF]: (type) => ({
        enum: Object.keys(type.keys),
    }),
    [IoTag.INTERSECTION]: (type) => ({
        allOf: type.types.map(type => convert(type)),
    }),
    [IoTag.ARRAY]: (type) => ({
        type: 'array',
        items: convert(type.type),
    }),
    [IoTag.TUPLE]: (type) => {
        const length = type.types.length;
        return {
            type: 'array',
            items: type.types.map(type => convert(type)),
            minItems: length,
            maxItems: length,
        };
    },
    [IoTag.INTERFACE]: (type, supertypes) => {
        let required = Object.keys(type.props);
        const properties = Object.entries(type.props)
            .reduce((result, [key, value]) => {
            // Convert children to JSON Schema
            const jsonSchemaValue = convert(value);
            // Un-require values that are unions with undefined
            if (removeUndefinedValuesFromUnion(jsonSchemaValue)) {
                required = required.filter(k => k !== key);
            }
            result[key] = jsonSchemaValue;
            return result;
        }, {});
        return {
            type: 'object',
            properties,
            required,
            additionalProperties: !supertypes.find(type => exports.getTag(type) === IoTag.EXACT),
        };
    },
    [IoTag.PARTIAL]: (type, supertypes) => ({
        type: 'object',
        properties: Object.entries(type.props)
            .reduce((result, [key, value]) => {
            result[key] = convert(value);
            return result;
        }, {}),
        additionalProperties: !supertypes.includes(type => exports.getTag(type) === IoTag.EXACT),
    }),
    [IoTag.DICTIONARY]: (type) => ({
        type: 'object',
        additionalProperties: convert(type.codomain),
    }),
    [IoTag.EXACT]: (type, supertypes) => convert(type.type, [...supertypes, type]),
    [IoTag.REFINEMENT]: (type, supertypes) => convert(type.type, [...supertypes, type]),
    [IoTag.CUSTOM_JSON_SCHEMA]: (type) => type.jsonSchema,
};
exports.getTag = (ioType) => {
    const tag = ioType._tag;
    if (!IoTypes[tag]) {
        throw new Error(`Unsupported type with tag: ${tag}\n${JSON.stringify(ioType, null, 2)}`);
    }
    return tag;
};
exports.getIoConverter = (tag) => IoTypes[tag];
const convert = (ioType, supertypes = []) => exports.getIoConverter(exports.getTag(ioType))(ioType, supertypes);
const filterTree = (element, matcher) => {
    if (Array.isArray(element)) {
        return element.filter(e => filterTree(e, matcher));
    }
    else if (typeof element === 'object') {
        const result = {};
        for (const key in element) {
            if (element.hasOwnProperty(key) && matcher(element[key])) {
                result[key] = filterTree(element[key], matcher);
            }
        }
        return result;
    }
    return matcher(element) ? element : undefined;
};
exports.mergeJsonObjects = (...schemas) => {
    const filteredSchemas = schemas.filter(Boolean);
    const result = filteredSchemas[0];
    for (const schema of filteredSchemas.slice(1)) {
        const { properties, required } = schema;
        result.properties = Object.assign({}, result.properties, properties);
        result.required = [...(result.required || []), ...(required || [])];
    }
    return result;
};
exports.ioTypeToJsonSchema = (ioType) => {
    if (!ioType) {
        return undefined;
    }
    const jsonSchema = convert(ioType);
    // Remove undefined elements, as the can not be a part of JSON Schema
    return filterTree(jsonSchema, element => element !== undefinedJsonType);
};
exports.withJsonSchema = (ioType, jsonSchema) => {
    const type = ioType;
    type._tag = IoTag.CUSTOM_JSON_SCHEMA;
    type.jsonSchema = jsonSchema;
    return type;
};
